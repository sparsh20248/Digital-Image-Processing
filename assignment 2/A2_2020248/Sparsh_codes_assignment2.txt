Question 1

import cv2 as cv
import numpy as np
from PIL import Image, ImageOps
import matplotlib.pyplot as plt
import math
#first we need to take input of the image

def salt_and_pepper(percent, img):
    salt = percent/2
    pepper = 1 - percent/2
    for i in range(len(img)):
        for j in range(len(img)):
            r = np.random.random()
            if r < salt:
                img[i][j] = 255
            elif r > pepper:
                img[i][j] = 0
            else: 
                img[i][j] = img[i][j]
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

def PNSR(img, img_):
    mse = np.mean((img - img_)**2)
    if mse == 0:
        return 100
    max_pixel = 255.0
    psnr = 20 * math.log10(max_pixel / math.sqrt(mse))
    print(psnr)
    return psnr

def read_image():
    img = Image.open('barbara_gray.bmp')
    img = ImageOps.grayscale(img)
    img = np.array(img)
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

def padding(img, img_size, ksize):
    temp = np.zeros((img_size + ksize, img_size + ksize), dtype = np.uint8)
    for i in range(img_size):
        for j in range(img_size):
            temp[i+ksize//2][j+ksize//2] = img[i][j]
    return temp

def median_filter(img, img_size, ksize):
    img = padding(img, len(img), ksize)
    img_size = len(img)
    temp = np.zeros((img_size - ksize,img_size - ksize), dtype = np.uint8)
    for i in range(img_size - ksize):
        for j in range(img_size - ksize):
            score = []
            for _i in range(ksize):
                for _j in range(ksize):
                    score.append(img[i+_i][j+_j])
            score.sort()
            number = score[len(score)//2]
            temp[i][j] = number
    print(temp.shape)
    plt.imshow(temp, cmap='gray')
    plt.show()
    return temp
    
img = read_image()
img_5 = salt_and_pepper(0.05, img.copy())
denoised_image = median_filter(img_5.copy(), len(img_5), 2)
PNSR(img, denoised_image)
denoised_image = median_filter(img_5.copy(), len(img_5), 3)
PNSR(img, denoised_image)

import cv2 as cv
import numpy as np
from PIL import Image, ImageOps
import matplotlib.pyplot as plt
#first we need to take input of the image

def salt_and_pepper(percent, img):
    salt = percent/2
    pepper = 1 - percent/2
    
    for i in range(len(img)):
        for j in range(len(img)):
            r = np.random.random()
            if r < salt:
                img[i][j] = 255
            elif r > pepper:
                img[i][j] = 0
            else: 
                img[i][j] = img[i][j]
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

def PNSR(img, img_):
    img = np.array(img)
    img_ = np.array(img_)
    mse = np.mean((img - img_)**2)
    if mse == 0:
        return 100
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))
    print(psnr)
    return psnr

def read_image():
    img = Image.open('barbara_gray.bmp')
    img = ImageOps.grayscale(img)
    img = np.array(img)
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

def padding(img, img_size, ksize):
    temp = np.zeros((img_size + ksize, img_size + ksize), dtype = np.uint8)
    for i in range(img_size):
        for j in range(img_size):
            temp[i+ksize//2][j+ksize//2] = img[i][j]
    return temp

def median_filter(img, img_size, ksize):
    img = padding(img, len(img), ksize)
    img_size = len(img)
    temp = np.zeros((img_size - ksize,img_size - ksize), dtype = np.uint8)
    for i in range(img_size - ksize):
        for j in range(img_size - ksize):
            score = []
            for _i in range(ksize):
                for _j in range(ksize):
                    score.append(img[i+_i][j+_j])
            score.sort()
            number = score[len(score)//2]
            temp[i][j] = number
    print(temp.shape)
    plt.imshow(temp, cmap='gray')
    plt.show()
    return temp
    
img = read_image()
img_5 = salt_and_pepper(0.15, img.copy())
denoised_image = median_filter(img_5.copy(), len(img_5), 3)
PNSR(img, denoised_image)
denoised_image = median_filter(img_5.copy(), len(img_5), 5)
PNSR(img, denoised_image)

import cv2 as cv
import numpy as np
from PIL import Image, ImageOps
import matplotlib.pyplot as plt
#first we need to take input of the image

def salt_and_pepper(percent, img):
    salt = percent/2
    pepper = 1 - percent/2
    print(len(img))
    print(len(img[0]))
    
    for i in range(len(img)):
        for j in range(len(img)):
            r = np.random.random()
            if r < salt:
                img[i][j] = 255
            elif r > pepper:
                img[i][j] = 0
            else: 
                img[i][j] = img[i][j]
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

def PNSR(img, img_):
    img = np.array(img)
    img_ = np.array(img_)
    mse = np.mean((img - img_)**2)
    if mse == 0:
        return 100
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))
    print(psnr)
    return psnr


def read_image():
    img = Image.open('barbara_gray.bmp')
    img = ImageOps.grayscale(img)
    img = np.array(img)
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

def padding(img, img_size, ksize):
    temp = np.zeros((img_size + ksize, img_size + ksize), dtype = np.uint8)
    for i in range(img_size):
        for j in range(img_size):
            temp[i+ksize//2][j+ksize//2] = img[i][j]
    return temp

def median_filter(img, img_size, ksize):
    img = padding(img, len(img), ksize)
    img_size = len(img)
    temp = np.zeros((img_size - ksize,img_size - ksize), dtype = np.uint8)
    for i in range(img_size - ksize):
        for j in range(img_size - ksize):
            score = []
            for _i in range(ksize):
                for _j in range(ksize):
                    score.append(img[i+_i][j+_j])
            score.sort()
            number = score[len(score)//2]
            temp[i][j] = number
    print(temp.shape)
    plt.imshow(temp, cmap='gray')
    plt.show()
    return temp
    
img = read_image()
img_5 = salt_and_pepper(0.20, img.copy())
denoised_image = median_filter(img_5.copy(), len(img_5), 5)
PNSR(img, denoised_image)
denoised_image = median_filter(img_5.copy(), len(img_5), 3)
PNSR(img, denoised_image)
denoised_image = median_filter(img_5.copy(), len(img_5), 4)
PNSR(img, denoised_image)


import cv2 as cv
import numpy as np
from PIL import Image, ImageOps
import matplotlib.pyplot as plt
#first we need to take input of the image

def salt_and_pepper(percent, img):
    salt = percent/2
    pepper = 1 - percent/2
    
    for i in range(len(img)):
        for j in range(len(img)):
            r = np.random.random()
            if r < salt:
                img[i][j] = 255
            elif r > pepper:
                img[i][j] = 0
            else: 
                img[i][j] = img[i][j]
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

def PNSR(img, img_):
    img = np.array(img)
    img_ = np.array(img_)
    mse = np.mean((img - img_)**2)
    if mse == 0:
        return 100
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))
    print(psnr)
    return psnr

def read_image():
    img = Image.open('barbara_gray.bmp')
    img = ImageOps.grayscale(img)
    img = np.array(img)
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

def padding(img, img_size, ksize):
    temp = np.zeros((img_size + ksize, img_size + ksize), dtype = np.uint8)
    for i in range(img_size):
        for j in range(img_size):
            temp[i+ksize//2][j+ksize//2] = img[i][j]
    return temp

def median_filter(img, img_size, ksize):
    img = padding(img, len(img), ksize)
    img_size = len(img)
    temp = np.zeros((img_size - ksize,img_size - ksize), dtype = np.uint8)
    for i in range(img_size - ksize):
        for j in range(img_size - ksize):
            score = []
            for _i in range(ksize):
                for _j in range(ksize):
                    score.append(img[i+_i][j+_j])
            score.sort()
            number = score[len(score)//2]
            temp[i][j] = number
    print(temp.shape)
    plt.imshow(temp, cmap='gray')
    plt.show()
    return temp
    
img = read_image()
img_5 = salt_and_pepper(0.25, img.copy())
denoised_image_1 = median_filter(img_5.copy(), len(img_5), 4)
PNSR(img, denoised_image_1)
denoised_image_2 = median_filter(img_5.copy(), len(img_5), 3)
PNSR(img, denoised_image_2)








Question 2










import cv2 as cv
import numpy as np
from PIL import Image, ImageOps
import matplotlib.pyplot as plt

#this function read the image and convert it to grayscale
def read_image():
    img = Image.open('cameraman.png')
    img = ImageOps.grayscale(img)
    img = np.array(img)
    temp = np.zeros((len(img) - 1, len(img) - 1), dtype = np.uint8)
    for i in range(512):
        for j in range(512):
            temp[i][j] = img[i][j]
    img = temp
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

#this function reduce the image size from 512x512 to 128x128
def reduce(img, times):
    img_size = len(img)
    temp = np.zeros((img_size // times, img_size // times), dtype = np.uint8)
    print(temp.shape)
    for i in range(0, img_size, times): 
        for j in range(0, img_size, times):
            temp[i//times][j//times] = img[i][j]
    print_image(temp)
    return temp        

#this function is used to make the kernal. 1-D kernal is made using the conditions given in the lecture notes and futher taking outer product we get the 
#2-D kernal. Here 1-d kernal is [0, 1, 1, 1, 1]
def make_kernal():
    a = [0, 1, 1, 1, 1]
    k = np.zeros((5, 5))
    for i in range(5):
        for j in range(5):
            k[i][j] = a[i] * a[j]
    return k


#this function acts like a convolution step. That is it fills all the values of new pixels that will be affected by our image. The weight here is defined 
#by the kernal. if the value is 200 and kernel is 0.5 then the new pixel value will be 100.
def convolve(k, temp, img, times, x, y):
    for i in range(0, 5):
        for j in range(0, 5):
            x_ = x * times + i - 2
            y_ = y * times + j - 2
            if(x_ < 0 or x_ >= 512 or y_ < 0 or y_>= 512):
                continue
            temp[x_][y_] += img[x][y] * k[i][j]

#this the bi-linear function. All tyhe functions will be the same, going to each pixel in the small image and changing all the effecting pixels in the new image.
def nearnest_N(img, times, kernel):
    img_size = len(img)
    temp = np.zeros((img_size * times, img_size * times), dtype = np.uint8)
    for i in range(img_size):
        for j in range(img_size):
            convolve(kernel, temp , img, times, i, j)
    print_image(temp)
    return temp
    
#this function is used to print the image
def print_image(img):
    plt.imshow(img, cmap='gray')
    plt.show()

#this function is used to calculate the PNSR
def PNSR(img, img_):
    img = np.array(img)
    img_ = np.array(img_)
    mse = np.mean((img - img_)**2)
    if mse == 0:
        return 100
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))
    print(psnr)
    return psnr

#this is the main funciton is used to make the calls to the functions.
# steps
# 1) we read the image
# 2) we make the kernal
# 3) we reduce the image size
# 4) we enlarge the image using our kernel
# 5) we calculate the PNSR
img = read_image()
kernel = make_kernal()
img_reduced= reduce(img.copy(), 4)
img_enlarged = nearnest_N(img_reduced.copy(), 4, kernel)
PNSR(img, img_enlarged)


import cv2 as cv
import numpy as np
from PIL import Image, ImageOps
import matplotlib.pyplot as plt

#this function read the image and convert it to grayscale
def read_image():
    img = Image.open('cameraman.png')
    img = ImageOps.grayscale(img)
    img = np.array(img)
    temp = np.zeros((len(img) - 1, len(img) - 1), dtype = np.uint8)
    for i in range(512):
        for j in range(512):
            temp[i][j] = img[i][j]
    img = temp
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

#this function reduce the image size from 512x512 to 128x128
def reduce(img, times):
    img_size = len(img)
    temp = np.zeros((img_size // times, img_size // times), dtype = np.uint8)
    print(temp.shape)
    for i in range(0, img_size, times): 
        for j in range(0, img_size, times):
            temp[i//times][j//times] = img[i][j]
    print_image(temp)
    return temp        

#this function is used to make the kernal. 1-D kernal is made using the conditions given in the lecture notes and futher taking outer product we get the 
#2-D kernal. Here 1-d kernal is [0, 0.03125, 0.125, 0.28125, 0.5, 0.6875, 0.75, 0.6875, 0.5, 0.28125, 0.125, 0.03125, 0 ]
def make_kernal():
    a = [0, 0.03125, 0.125, 0.28125, 0.5, 0.6875, 0.75, 0.6875, 0.5, 0.28125, 0.125, 0.03125, 0 ]
    k = np.zeros((13, 13))
    for i in range(13):
        for j in range(13):
            k[i][j] = a[i] * a[j]
    return k


#this function acts like a convolution step. That is it fills all the values of new pixels that will be affected by our image. The weight here is defined 
#by the kernal. if the value is 200 and kernel is 0.5 then the new pixel value will be 100.
def convolve(k, temp, img, times, x, y):
    for i in range(0, 13):
        for j in range(0, 13):
            x_ = x * times + i - 6
            y_ = y * times + j - 6
            if(x_ < 0 or x_ >= 512 or y_ < 0 or y_>= 512):
                continue
            temp[x_][y_] += img[x][y] * k[i][j]

#this the bi-linear function. All tyhe functions will be the same, going to each pixel in the small image and changing all the effecting pixels in the new image.
def b_spline(img, times, kernel):
    img_size = len(img)
    temp = np.zeros((img_size * times, img_size * times), dtype = np.uint8)
    for i in range(img_size):
        for j in range(img_size):
            convolve(kernel, temp , img, times, i, j)
    print_image(temp)
    return temp
    
#this function is used to print the image
def print_image(img):
    plt.imshow(img, cmap='gray')
    plt.show()

#this function is used to calculate the PNSR
def PNSR(img, img_):
    img = np.array(img)
    img_ = np.array(img_)
    mse = np.mean((img - img_)**2)
    if mse == 0:
        return 100
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))
    print(psnr)
    return psnr

#this is the main funciton is used to make the calls to the functions.
# steps
# 1) we read the image
# 2) we make the kernal
# 3) we reduce the image size
# 4) we enlarge the image using our kernel
# 5) we calculate the PNSR
img = read_image()
kernel = make_kernal()
img_reduced= reduce(img.copy(), 4)
img_enlarged = b_spline(img_reduced.copy(), 4, kernel)
PNSR(img, img_enlarged)


import cv2 as cv
import numpy as np
from PIL import Image, ImageOps
import matplotlib.pyplot as plt

#this function read the image and convert it to grayscale
def read_image():
    img = Image.open('cameraman.png')
    img = ImageOps.grayscale(img)
    img = np.array(img)
    temp = np.zeros((len(img) - 1, len(img) - 1), dtype = np.uint8)
    for i in range(512):
        for j in range(512):
            temp[i][j] = img[i][j]
    img = temp
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

#this function reduce the image size from 512x512 to 128x128
def reduce(img, times):
    img_size = len(img)
    temp = np.zeros((img_size // times, img_size // times), dtype = np.uint8)
    print(temp.shape)
    for i in range(0, img_size, times): 
        for j in range(0, img_size, times):
            temp[i//times][j//times] = img[i][j]
    print_image(temp)
    return temp        

#this function is used to make the kernal. 1-D kernal is made using the conditions given in the lecture notes and futher taking outer product we get the 
#2-D kernal. Here 1-d kernal is [0, 1/4, 2/4, 3/4 , 1, 3/4, 2/4, 1/4, 0]. 
def make_kernal():
    k = [0, 1/4, 2/4, 3/4 , 1, 3/4, 2/4, 1/4, 0]
    kernal = np.zeros((9, 9))
    for i in range(9):
        for j in range(9):
            kernal[i][j] = k[i] * k[j]
    return kernal


#this function acts like a convolution step. That is it fills all the values of new pixels that will be affected by our image. The weight here is defined 
#by the kernal. if the value is 200 and kernel is 0.5 then the new pixel value will be 100.
def convolve(k, temp, img, times, x, y):
    for i in range(0, 9):
        for j in range(0, 9):
            x_ = x * times + i - 4
            y_ = y * times + j - 4
            if(x_ < 0 or x_ >= 512 or y_ < 0 or y_>= 512):
                continue
            temp[x_][y_] += img[x][y] * k[i][j]

#this the bi-linear function. All tyhe functions will be the same, going to each pixel in the small image and changing all the effecting pixels in the new image.
def bilinear(img, times, kernel):
    img_size = len(img)
    temp = np.zeros((img_size * times, img_size * times), dtype = np.uint8)
    for i in range(img_size):
        for j in range(img_size):
            convolve(kernel, temp , img, times, i, j)
    print_image(temp)
    return temp
    
#this function is used to print the image
def print_image(img):
    plt.imshow(img, cmap='gray')
    plt.show()

#this function is used to calculate the PNSR
def PNSR(img, img_):
    img = np.array(img)
    img_ = np.array(img_)
    mse = np.mean((img - img_)**2)
    if mse == 0:
        return 100
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))
    print(psnr)
    return psnr

#this is the main funciton is used to make the calls to the functions.
# steps
# 1) we read the image
# 2) we make the kernal
# 3) we reduce the image size
# 4) we enlarge the image using our kernel
# 5) we calculate the PNSR
img = read_image()
kernel = make_kernal()
img_reduced= reduce(img.copy(), 4)
img_enlarged = bilinear(img_reduced.copy(), 4, kernel)
PNSR(img, img_enlarged)


import cv2 as cv
import numpy as np
from PIL import Image, ImageOps
import matplotlib.pyplot as plt

#this function read the image and convert it to grayscale
def read_image():
    img = Image.open('cameraman.png')
    img = ImageOps.grayscale(img)
    img = np.array(img)
    temp = np.zeros((len(img) - 1, len(img) - 1), dtype = np.uint8)
    for i in range(512):
        for j in range(512):
            temp[i][j] = img[i][j]
    img = temp
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

#this function reduce the image size from 512x512 to 128x128
def reduce(img, times):
    img_size = len(img)
    temp = np.zeros((img_size // times, img_size // times), dtype = np.uint8)
    print(temp.shape)
    for i in range(0, img_size, times): 
        for j in range(0, img_size, times):
            temp[i//times][j//times] = img[i][j]
    return temp        

#this function is used to make the kernal. 1-D kernal is made using the conditions given in the lecture notes and futher taking outer product we get the 
#2-D kernal. Here 1-d kernal is [0, 0.15625, 2/4, 0.84375 , 1, 0.84375, 2/4, 0.15625, 0]
def make_kernal():
    a = [0, 0.15625, 2/4, 0.84375 , 1, 0.84375, 2/4, 0.15625, 0]
    k = np.zeros((9, 9))
    for i in range(9):
        for j in range(9):
            k[i][j] = a[i] * a[j]
    return k


#this function acts like a convolution step. That is it fills all the values of new pixels that will be affected by our image. The weight here is defined 
#by the kernal. if the value is 200 and kernel is 0.5 then the new pixel value will be 100.
def convolve(k, temp, img, times, x, y):
    for i in range(0, 9):
        for j in range(0, 9):
            x_ = x * times + i - 4
            y_ = y * times + j - 4
            if(x_ < 0 or x_ >= 512 or y_ < 0 or y_>= 512):
                continue
            temp[x_][y_] += img[x][y] * k[i][j]

#this the bi-linear function. All tyhe functions will be the same, going to each pixel in the small image and changing all the effecting pixels in the new image.
def hermite(img, times, kernel):
    img_size = len(img)
    temp = np.zeros((img_size * times, img_size * times), dtype = np.uint8)
    for i in range(img_size):
        for j in range(img_size):
            convolve(kernel, temp , img, times, i, j)
    print_image(temp)
    return temp
    
#this function is used to print the image
def print_image(img):
    plt.imshow(img, cmap='gray')
    plt.show()

#this function is used to calculate the PNSR
def PNSR(img, img_):
    img = np.array(img)
    img_ = np.array(img_)
    mse = np.mean((img - img_)**2)
    if mse == 0:
        return 100
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))
    print(psnr)
    return psnr

#this is the main funciton is used to make the calls to the functions.
# steps
# 1) we read the image
# 2) we make the kernal
# 3) we reduce the image size
# 4) we enlarge the image using our kernel
# 5) we calculate the PNSR
img = read_image()
kernel = make_kernal()
img_reduced= reduce(img.copy(), 4)
img_enlarged = hermite(img_reduced.copy(), 4, kernel)
PNSR(img, img_enlarged)


import cv2 as cv
import numpy as np
from PIL import Image, ImageOps
import matplotlib.pyplot as plt

#this function read the image and convert it to grayscale
def read_image():
    img = Image.open('cameraman.png')
    img = ImageOps.grayscale(img)
    img = np.array(img)
    temp = np.zeros((len(img) - 1, len(img) - 1), dtype = np.uint8)
    for i in range(512):
        for j in range(512):
            temp[i][j] = img[i][j]
    img = temp
    plt.imshow(img, cmap='gray')
    plt.show()
    return img

#this function reduce the image size from 512x512 to 128x128
def reduce(img, times):
    img_size = len(img)
    temp = np.zeros((img_size // times, img_size // times), dtype = np.uint8)
    print(temp.shape)
    for i in range(0, img_size, times): 
        for j in range(0, img_size, times):
            temp[i//times][j//times] = img[i][j]
    return temp        

#this function is used to make the kernal. 1-D kernal is made using the conditions given in the lecture notes and futher taking outer product we get the 
#2-D kernal. Here 1-d kernal is [0, 0.0234375, 0.0625, 0.0703125, 0, 0.0859375, 0.4375, 0.820312, 1, 0.820312, 0.4375, 0.0859375, 0, 0.0703125, 0.0625, 0.0234375, 0]
def make_kernal():
    a = [0, 0.0234375, 0.0625, 0.0703125, 0, 0.0859375, 0.4375, 0.820312, 1, 0.820312, 0.4375, 0.0859375, 0, 0.0703125, 0.0625, 0.0234375, 0]
    k = np.zeros((17, 17))
    for i in range(17):
        for j in range(17):
            k[i][j] = a[i] * a[j]
    return k


#this function acts like a convolution step. That is it fills all the values of new pixels that will be affected by our image. The weight here is defined 
#by the kernal. if the value is 200 and kernel is 0.5 then the new pixel value will be 100.
def convolve(k, temp, img, times, x, y):
    for i in range(0, 17):
        for j in range(0, 17):
            x_ = x * times + i - 8
            y_ = y * times + j - 8
            if(x_ < 0 or x_ >= 512 or y_ < 0 or y_>= 512):
                continue
            temp[x_][y_] += img[x][y] * k[i][j]

#this the bi-linear function. All tyhe functions will be the same, going to each pixel in the small image and changing all the effecting pixels in the new image.
def bi_cubic(img, times, kernel):
    img_size = len(img)
    temp = np.zeros((img_size * times, img_size * times), dtype = np.uint8)
    for i in range(img_size):
        for j in range(img_size):
            convolve(kernel, temp , img, times, i, j)
    print_image(temp)
    return temp
    
#this function is used to print the image
def print_image(img):
    plt.imshow(img, cmap='gray')
    plt.show()

#this function is used to calculate the PNSR
def PNSR(img, img_):
    img = np.array(img)
    img_ = np.array(img_)
    mse = np.mean((img - img_)**2)
    if mse == 0:
        return 100
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))
    print(psnr)
    return psnr

#this is the main funciton is used to make the calls to the functions.
# steps
# 1) we read the image
# 2) we make the kernal
# 3) we reduce the image size
# 4) we enlarge the image using our kernel
# 5) we calculate the PNSR
img = read_image()
kernel = make_kernal()
img_reduced= reduce(img.copy(), 4)
img_enlarged = bi_cubic(img_reduced.copy(), 4, kernel)
PNSR(img, img_enlarged)




